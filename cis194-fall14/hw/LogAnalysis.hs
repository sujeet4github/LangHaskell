{-# OPTIONS_GHC -Wall #-}
module LogAnalysis where

import Log
import Data.List(sortBy,isInfixOf)
import Data.Text(toLower, unpack, pack)

-- Functions which may (or may not) be useful to you include
-- lines, words, unwords, take, drop, (.), map, and filter.

-- Helper functions
timestamp :: LogMessage -> TimeStamp
timestamp (LogMessage _ ts _) = ts
message :: LogMessage -> String
message (LogMessage _ _ m)  = m

-- Exercise 1
-- The first step is figuring out how to parse an individual
-- message
parseMessage :: String -> MaybeLogMessage
parseMessage m =
    let
        ws = words m
        parseInfoMessage t xs =
            case (readInt t) of
                (ValidInt i)    -> ValidLM ( LogMessage Info i (unwords xs) )
                _               -> InvalidLM ("Not a valid log message: timestamp should be integer, received as " ++ t)
        parseWarningMessage t xs =
            case (readInt t) of
                (ValidInt i)    -> ValidLM ( LogMessage Warning i (unwords xs) )
                _               -> InvalidLM ("Not a valid log message: timestamp should be integer, received as " ++ t)
        parseErrorMessage e t xs =
            case (readInt e) of
                (ValidInt en)   ->
                    case (readInt t) of
                        (ValidInt tn)   -> ValidLM ( LogMessage (Error en) tn (unwords xs) )
                        _               -> InvalidLM ("Not a valid log message: timestamp should be integer, received as " ++ t)
                _               -> InvalidLM ("Not a valid log message: error number should be integer, received as " ++ e)
    in
        case ws of
            ("I":t:xs)  -> parseInfoMessage t xs
            ("W":t:xs)  -> parseWarningMessage t xs
            ("E":e:t:xs)-> parseErrorMessage e t xs
            _           -> InvalidLM m

t1 :: Bool
t1 = parseMessage "E 2 562 help help"
    == ValidLM (LogMessage (Error 2) 562 "help help")
t2 :: Bool
t2 = parseMessage "I 29 la la la"
    == ValidLM (LogMessage Info 29 "la la la")
t3 :: Bool
t3 = parseMessage "This is not in the right format"
    == InvalidLM "This is not in the right format"

-- Exercise 2 It’s not terribly hard to make parseMessage work over all
-- the lines in a file. But, doing so would produce a [MaybeLogMessage],
-- where we really just want a [LogMessage] for further processing –
-- let’s throw out the invalid messages.
validMessagesOnly :: [MaybeLogMessage] -> [LogMessage]
validMessagesOnly = concat . (map getLogMessage)
    where
        getLogMessage (ValidLM m)   = [m]
        getLogMessage _             = []

-- Exercise 3
-- which parses an entire log file at once and returns its contents as a
-- list of LogMessages
parse :: String -> [LogMessage]
parse = validMessagesOnly . map parseMessage . lines

{-
Unfortunately, due to the error messages being generated by multiple
servers in multiple locations around the globe, a lightning storm, a
failed disk, and a bored yet incompetent programmer, the log messages
are horribly out of order. Until we do some organizing, there
will be no way to make sense of what went wrong!

-}
-- Exercise 4
compareMsgs :: LogMessage -> LogMessage -> Ordering
compareMsgs m1 m2 = (timestamp m1) `compare` (timestamp m2)


t4 :: Bool
t4 = LT == compareMsgs
            (LogMessage Warning 153 "Not a speck of light is showing, so the danger must be growing...")
            (LogMessage Info 208 "the Weighted Companion Cube cannot talk")

t5 :: Bool
t5 = EQ == compareMsgs
            (LogMessage (Error 101) 2001 "My God! It's full of stars!")
            (LogMessage Info 2001 "Daisy, Daisy, give me your answer do.")

-- Exercise 5
sortMessages :: [LogMessage] -> [LogMessage]
sortMessages = sortBy compareMsgs

-- Exercise 6
-- Now that we can sort the log messages, the only thing
-- left to do is extract the relevant information. We have decided that
-- “relevant” means “errors with a severity of at least 50”.
whatWentWrong :: [LogMessage] -> [String]
whatWentWrong = (map message) . filter (e50)
    where
        e50 (LogMessage (Error n) _ _)  = n >= 50
        e50 _                           = False

t6 :: IO()
t6 = testWhatWentWrong (sortMessages . parse) whatWentWrong "error.log"

-- Exercise 7
messagesAbout :: String -> [LogMessage] -> [LogMessage]
messagesAbout s ms = filter (messageContains s) ms

messageContains :: [Char] -> LogMessage -> Bool
messageContains s lm =
    let
        lhsStr = (unpack . toLower . pack)
        rhsMesg = (unpack . toLower . pack. message)
    in
        (lhsStr s) `isInfixOf` (rhsMesg lm)

t7 :: [LogMessage]
t7 = messagesAbout "relish" [LogMessage (Error 101) 2001 "My God! It's full of stars! theRelish"]

-- Exercise 8
whatWentWrongEnhanced :: String -> [LogMessage] -> [String]
whatWentWrongEnhanced s ms = map message (filter (e50orHasStr s) ms)
    where
        e50 (LogMessage (Error n) _ _)  = n >= 50
        e50 _                           = False
        e50orHasStr str    = e50 ||| (messageContains str)

t8 :: [String]
t8 = whatWentWrongEnhanced "relish" [LogMessage (Error 101) 2001 "My God! It's full of stars!", LogMessage Info 2001 "My God! It's full of RELISH!"]

(|||) :: (LogMessage -> Bool) -> (LogMessage -> Bool) -> LogMessage -> Bool
(|||) f g x = f x || g x -- (||) is Haskell’s ordinary "or" operator

t10 :: [LogMessage] -> [String]
t10 = whatWentWrongEnhanced "relish"

testt10 :: IO [String]
testt10 = do
        sl <- readFile "error.log"
        let lms = parse sl
        let result = t10 lms
        return result
{-
-}